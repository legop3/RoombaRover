// services/mediamtxManager.js
const fs = require('fs');
const path = require('path');
const net = require('net');
const { spawn } = require('child_process');

const config = require('../helpers/config');
const { createLogger } = require('../helpers/logger');
const { io } = require('../globals/wsSocketExpress');

const logger = createLogger('MediaMTX');

// --- Config (kept minimal; uses your known-good defaults) ---
const CAMERA_DEVICE_PATH = (config.mediamtx && config.mediamtx.cameraDevicePath) || '/dev/video2';
const AUDIO_DEVICE_ALSA  = (config.mediamtx && config.mediamtx.audioDevice)     || 'hw:2,0';
const STREAM_NAME        = (config.mediamtx && config.mediamtx.streamName)      || 'rover-video';

const WEBRTC_UDP = (config.mediamtx && config.mediamtx.webrtcUdpPort) || 8189;
const WEBRTC_TCP = (config.mediamtx && config.mediamtx.webrtcTcpPort) || 8189;
const ADDITIONAL_HOSTS = (config.mediamtx && config.mediamtx.additionalHosts) || ['rover.otter.land', '184.58.6.151', '192.168.0.173', 'otter.land'];

const MEDIAMTX_BINARY_PATH = (config.mediamtx && config.mediamtx.binaryPath) || 'mediamtx';
const FFMPEG_BINARY_PATH   = (config.mediamtx && config.mediamtx.ffmpegPath) || 'ffmpeg';
const CONFIG_DIR           = (config.mediamtx && config.mediamtx.configDir)  || path.join(process.cwd(), 'runtime');
const AUTO_START           = !!(config.mediamtx && config.mediamtx.autoStart);

const HTTP_PORT = 8889; // mediamtx default
const RTSP_PORT = 8554; // mediamtx default

logger.info(`Using MediaMTX binary: ${MEDIAMTX_BINARY_PATH}`);
logger.info(`Using FFMPEG binary: ${FFMPEG_BINARY_PATH}`);
logger.info(`Using camera device: ${CAMERA_DEVICE_PATH}`);
logger.info(`Using audio device: ${AUDIO_DEVICE_ALSA}`);

// --- Internal state ---
let mediamtxProcess = null;
let ffmpegProcess = null;

const state = {
  mediamtx: { running: false, pid: null, startedAt: null, lastError: null },
  ffmpeg:   { running: false, pid: null, startedAt: null, lastError: null }
};

// Backoff schedulers
const sched = {
  mtx: { timer: null, attempt: 0 },
  ff:  { timer: null, attempt: 0 },
};

function emitStatus() {
  io.emit('mediamtx:status', { ...state.mediamtx });
  io.emit('ffmpeg:status',   { ...state.ffmpeg });
}
function emitLog(ch, line) { io.emit(`${ch}:log`, String(line)); }
function emitErr(ch, msg)  { io.emit(`${ch}:error`, String(msg)); }

function clearTimer(which) {
  if (sched[which].timer) { clearTimeout(sched[which].timer); sched[which].timer = null; }
}

function backoff(which, fn) {
  clearTimer(which);
  const a = ++sched[which].attempt;
  const base = 600; // ms
  const max  = 10000;
  const delay = Math.min(max, Math.floor(base * Math.pow(1.8, a)));
  const jitter = Math.floor(Math.random() * 250);
  sched[which].timer = setTimeout(() => {
    sched[which].timer = null;
    fn().catch(() => {}); // swallow, we’ll reschedule internally
  }, delay + jitter);
}

// Guard multiple awaits
function waitForTcp(host, port, timeoutMs = 12000, intervalMs = 150) {
  return new Promise((resolve, reject) => {
    const start = Date.now();
    const tryOnce = () => {
      const s = new net.Socket();
      let done = false;
      s.once('connect', () => { done = true; s.destroy(); resolve(); });
      s.once('error', () => {
        if (done) return;
        s.destroy();
        if (Date.now() - start > timeoutMs) reject(new Error(`Timeout waiting for ${host}:${port}`));
        else setTimeout(tryOnce, intervalMs);
      });
      s.setTimeout(intervalMs, () => { if (!done) { s.destroy(); setTimeout(tryOnce, intervalMs); } });
      try { s.connect(port, host); } catch { setTimeout(tryOnce, intervalMs); }
    };
    tryOnce();
  });
}

// --- Config file generation (exact semantics you provided) ---
function buildMTXYamlExact() {
  const hosts = ADDITIONAL_HOSTS.map(h => `"${h}"`).join(', ');
  return `# Generated by mediamtxManager.js

webrtcLocalUDPAddress: :${WEBRTC_UDP}
webrtcLocalTCPAddress: :${WEBRTC_TCP}
webrtcAdditionalHosts: [ ${hosts} ]

webrtcICEServers2:
  - url: stun:stun.l.google.com:19302
  # - url: turn:turn.yourdomain.example:3478
  #   username: webrtc
  #   password: secret

# httpAddress: :${HTTP_PORT}
# webrtcAddress: :${HTTP_PORT}
# rtspAddress: :${RTSP_PORT}

paths:
  all:
    source: publisher
`;
}

function safeWriteMTXConfig() {
  try {
    fs.mkdirSync(CONFIG_DIR, { recursive: true });
    const cfgPath = path.join(CONFIG_DIR, 'mediamtx.yml');
    fs.writeFileSync(cfgPath, buildMTXYamlExact(), 'utf8');
    return cfgPath;
  } catch (e) {
    const msg = `Failed to write mediamtx.yml: ${e.message}`;
    logger.error(msg);
    emitErr('mediamtx', msg);
    return null;
  }
}

// --- Start/Stop MediaMTX (fail-safe) ---
async function startMediaMTX() {
  // If already running or starting, no-op
  if (mediamtxProcess || state.mediamtx.running) return;

  clearTimer('mtx');
  state.mediamtx.lastError = null;
  emitStatus();

  const cfgPath = safeWriteMTXConfig();
  if (!cfgPath) {
    state.mediamtx.lastError = 'config-write-failed';
    emitStatus();
    backoff('mtx', startMediaMTX);
    return;
  }

  let child;
  try {
    logger.info(`Starting MediaMTX with ${cfgPath}`);
    child = spawn(MEDIAMTX_BINARY_PATH, [cfgPath], { stdio: ['ignore', 'pipe', 'pipe'] });
  } catch (e) {
    const msg = e && e.code === 'ENOENT'
      ? `MediaMTX binary not found: ${MEDIAMTX_BINARY_PATH}`
      : `Failed to spawn MediaMTX: ${e.message}`;
    logger.error(msg);
    state.mediamtx.lastError = msg;
    emitErr('mediamtx', msg);
    emitStatus();
    backoff('mtx', startMediaMTX);
    return;
  }

  mediamtxProcess = child;
  state.mediamtx = { running: true, pid: child.pid, startedAt: Date.now(), lastError: null };
  emitStatus();

  child.on('error', (err) => {
    const msg = `MediaMTX process error: ${err.message}`;
    logger.error(msg);
    emitErr('mediamtx', msg);
  });

  child.stdout.on('data', d => emitLog('mediamtx', d.toString()));
  child.stderr.on('data', d => emitLog('mediamtx', d.toString()));

  child.on('exit', (code, signal) => {
    logger.warn(`MediaMTX exited (code=${code}, signal=${signal})`);
    mediamtxProcess = null;
    state.mediamtx = { running: false, pid: null, startedAt: null, lastError: state.mediamtx.lastError };
    emitStatus();

    // If FFmpeg is running, stop it (publisher will be gone)
    if (ffmpegProcess) stopFFmpeg();

    // retry automatically
    backoff('mtx', startMediaMTX);
  });

  // Don’t crash if ports aren’t open—just retry later
  try {
    await waitForTcp('127.0.0.1', HTTP_PORT, 12000);
    await waitForTcp('127.0.0.1', RTSP_PORT, 12000);
    logger.info('MediaMTX is listening.');
    // reset backoff on success
    sched.mtx.attempt = 0;
  } catch (e) {
    const msg = `MediaMTX ports not listening yet: ${e.message}`;
    logger.warn(msg);
    emitErr('mediamtx', msg);
    // FFmpeg start will also wait on RTSP when needed
  }
}

function stopMediaMTX() {
  clearTimer('mtx');
  if (!mediamtxProcess) return;
  logger.info('Stopping MediaMTX…');
  try { mediamtxProcess.kill('SIGTERM'); } catch {}
}

function killMediaMTXHard() {
  if (!mediamtxProcess) return;
  try { mediamtxProcess.kill('SIGKILL'); } catch {}
}

// --- FFmpeg (fail-safe) ---
function ffmpegArgsExact() {
  return [
    '-fflags', 'nobuffer', '-flags', 'low_delay', '-use_wallclock_as_timestamps', '1',
    '-thread_queue_size', '512',
    '-f', 'v4l2', '-input_format', 'h264', '-framerate', '30', '-video_size', '640x480', '-i', CAMERA_DEVICE_PATH,
    '-thread_queue_size', '512',
    '-f', 'alsa', '-ac', '1', '-ar', '48000', '-i', AUDIO_DEVICE_ALSA,
    '-map', '0:v:0', '-map', '1:a:0',
    '-c:v', 'copy',
    '-c:a', 'libopus', '-b:a', '64k', '-ar', '48000', '-ac', '1', '-application', 'lowdelay', '-frame_duration', '20',
    '-muxdelay', '0', '-muxpreload', '0', '-max_interleave_delta', '0',
    '-f', 'rtsp', '-rtsp_transport', 'tcp',
    `rtsp://127.0.0.1:${RTSP_PORT}/${encodeURIComponent(STREAM_NAME)}`
  ];
}

async function startFFmpeg() {
  if (ffmpegProcess || state.ffmpeg.running) return;

  clearTimer('ff');
  state.ffmpeg.lastError = null;
  emitStatus();

  // Ensure MTX is (attempting to be) up
  if (!mediamtxProcess && !state.mediamtx.running) await startMediaMTX();

  // Wait a bit for RTSP; do not throw—just retry if not ready
  try { await waitForTcp('127.0.0.1', RTSP_PORT, 10000); } catch {}

  let child;
  try {
    const args = ffmpegArgsExact();
    logger.info(`Starting FFmpeg: ${FFMPEG_BINARY_PATH} ${args.join(' ')}`);
    child = spawn(FFMPEG_BINARY_PATH, args, { stdio: ['ignore', 'pipe', 'pipe'] });
  } catch (e) {
    const msg = e && e.code === 'ENOENT'
      ? `FFmpeg binary not found: ${FFMPEG_BINARY_PATH}`
      : `Failed to spawn FFmpeg: ${e.message}`;
    logger.error(msg);
    state.ffmpeg.lastError = msg;
    emitErr('ffmpeg', msg);
    emitStatus();
    backoff('ff', startFFmpeg);
    return;
  }

  ffmpegProcess = child;
  state.ffmpeg = { running: true, pid: child.pid, startedAt: Date.now(), lastError: null };
  emitStatus();

  child.on('error', (err) => {
    const msg = `FFmpeg process error: ${err.message}`;
    logger.error(msg);
    emitErr('ffmpeg', msg);
  });

  child.stdout.on('data', d => emitLog('ffmpeg', d.toString()));
  child.stderr.on('data', d => {
    const line = d.toString();
    emitLog('ffmpeg', line);

    // Common device errors -> mark and schedule retry, but don't crash
    if (/\bNo such file or directory\b|\bInput\/output error\b|\bDevice or resource busy\b/i.test(line)) {
      state.ffmpeg.lastError = line.trim();
      emitStatus();
    }
  });

  child.on('exit', (code, signal) => {
    logger.warn(`FFmpeg exited (code=${code}, signal=${signal})`);
    ffmpegProcess = null;
    state.ffmpeg = { running: false, pid: null, startedAt: null, lastError: state.ffmpeg.lastError };
    emitStatus();

    // If MTX is down, FFmpeg will be retried once MTX restarts anyway
    backoff('ff', startFFmpeg);
  });
}

function stopFFmpeg() {
  clearTimer('ff');
  if (!ffmpegProcess) return;
  logger.info('Stopping FFmpeg…');
  try { ffmpegProcess.kill('SIGTERM'); } catch {}
}

function killFFmpegHard() {
  if (!ffmpegProcess) return;
  try { ffmpegProcess.kill('SIGKILL'); } catch {}
}

// --- High-level control ---
async function startAV() {
  await startMediaMTX();
  await startFFmpeg();
}
function stopAV() {
  stopFFmpeg();
  setTimeout(stopMediaMTX, 400);
}

// --- Socket.IO wiring (defensive; never throws) ---
io.on('connection', (socket) => {
  socket.on('mediamtx:start', () => { startMediaMTX().catch(()=>{}); });
  socket.on('mediamtx:stop',  () => { stopMediaMTX(); });
  socket.on('mediamtx:restart', () => { stopMediaMTX(); setTimeout(()=> startMediaMTX().catch(()=>{}), 700); });
  socket.on('mediamtx:status', () => emitStatus());

  socket.on('ffmpeg:start', () => { startFFmpeg().catch(()=>{}); });
  socket.on('ffmpeg:stop',  () => { stopFFmpeg(); });
  socket.on('ffmpeg:restart', () => { stopFFmpeg(); setTimeout(()=> startFFmpeg().catch(()=>{}), 700); });
  socket.on('ffmpeg:status', () => emitStatus());

  socket.on('av:start', () => { startAV().catch(()=>{}); });
  socket.on('av:stop',  () => { stopAV(); });
  socket.on('av:restart', () => { stopAV(); setTimeout(()=> startAV().catch(()=>{}), 1000); });

  emitStatus();
});

// --- Process-level safety ---
function cleanup() {
  try { stopFFmpeg(); } catch {}
  try { stopMediaMTX(); } catch {}
  setTimeout(() => {
    try { killFFmpegHard(); } catch {}
    try { killMediaMTXHard(); } catch {}
  }, 2500);
}
function shutdown(code = 0) {
    // stop backoff timers so nothing restarts
    try { if (sched.ff.timer) clearTimeout(sched.ff.timer); } catch {}
    try { if (sched.mtx.timer) clearTimeout(sched.mtx.timer); } catch {}
  
    // stop processes gracefully
    try { stopFFmpeg(); } catch {}
    try { stopMediaMTX(); } catch {}
  
    // hard-kill after a grace period to avoid orphaned children
    setTimeout(() => {
      try { killFFmpegHard(); } catch {}
      try { killMediaMTXHard(); } catch {}
      // finally, exit this Node process
      process.exit(code);
    }, 2500);
  }
  
  // Use once() so multiple signals don’t stack cleanups
  process.once('SIGINT',  () => { logger.info('SIGINT received');  shutdown(0); });
  process.once('SIGTERM', () => { logger.info('SIGTERM received'); shutdown(0); });
  
  // (Optional) if you use nodemon, it sends SIGUSR2 for restarts:
  process.once('SIGUSR2', () => { logger.info('SIGUSR2'); shutdown(0); });
  
  // Keep these to avoid crashes during dev; they do NOT exit.
  process.on('uncaughtException', (err) => {
    logger.error(`uncaughtException: ${err.stack || err.message}`);
    emitErr('manager', `uncaughtException: ${err.message}`);
  });
  process.on('unhandledRejection', (reason) => {
    logger.error(`unhandledRejection: ${reason && reason.stack || reason}`);
    emitErr('manager', `unhandledRejection: ${reason}`);
  });
  
// Optional autostart
(async () => {
  if (AUTO_START) {
    logger.info('Auto-start enabled: starting MediaMTX + FFmpeg…');
    try { await startAV(); } catch (e) { logger.error(`Auto-start failed: ${e.message}`); }
  }
})();

module.exports = {
  startMediaMTX, stopMediaMTX,
  startFFmpeg,   stopFFmpeg,
  startAV,       stopAV,
  status: () => ({ mediamtx: state.mediamtx, ffmpeg: state.ffmpeg })
};
