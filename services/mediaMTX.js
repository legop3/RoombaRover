const fs = require('fs');
const path = require('path');
const net = require('net');
const { spawn } = require('child_process');

const config = require('../helpers/config');
const { createLogger } = require('../helpers/logger');
const { io } = require('../globals/wsSocketExpress');

const logger = createLogger('MediaMTX');

// ----- Config (defaults match your working setup) -----
const CAMERA_DEVICE_PATH = (config.mediamtx && config.mediamtx.cameraDevicePath) || '/dev/video2';
const AUDIO_DEVICE_ALSA  = (config.mediamtx && config.mediamtx.audioDevice)     || 'hw:2,0';
const STREAM_NAME        = (config.mediamtx && config.mediamtx.streamName)      || 'rover-video';

const WEBRTC_UDP = (config.mediamtx && config.mediamtx.webrtcUdpPort) || 8189;
const WEBRTC_TCP = (config.mediamtx && config.mediamtx.webrtcTcpPort) || 8189;
const ADDITIONAL_HOSTS = (config.mediamtx && config.mediamtx.additionalHosts) || ['rover.otter.land', '184.58.6.151', '192.168.0.173', 'otter.land'];

const MEDIAMTX_BINARY_PATH = (config.mediamtx && config.mediamtx.binaryPath) || 'mediamtx';
const FFMPEG_BINARY_PATH   = (config.mediamtx && config.mediamtx.ffmpegPath) || 'ffmpeg';
const CONFIG_DIR           = (config.mediamtx && config.mediamtx.configDir)  || path.join(process.cwd(), 'runtime');
const AUTO_START           = !!(config.mediamtx && config.mediamtx.autoStart);

// Fixed (matching your pasted mediamtx.yml defaults)
const HTTP_PORT = 8889; // httpAddress / webrtcAddress (defaults in mediamtx)
const RTSP_PORT = 8554; // rtspAddress

logger.info(`Using MediaMTX binary: ${MEDIAMTX_BINARY_PATH}`);
logger.info(`Using FFMPEG binary: ${FFMPEG_BINARY_PATH}`);
logger.info(`Using camera device: ${CAMERA_DEVICE_PATH}`);
logger.info(`Using audio device: ${AUDIO_DEVICE_ALSA}`);

let mediamtxProcess = null;
let ffmpegProcess = null;
let startingMTX = false;
let startingFF  = false;

const state = {
  mediamtx: { running: false, pid: null, startedAt: null },
  ffmpeg:   { running: false, pid: null, startedAt: null }
};

function emitStatus() {
  io.emit('mediamtx:status', { ...state.mediamtx });
  io.emit('ffmpeg:status',   { ...state.ffmpeg });
}
function emitLog(ch, line) { io.emit(`${ch}:log`, line); }
function emitErr(ch, msg)  { io.emit(`${ch}:error`, msg); }

function ensureDir(p) { fs.mkdirSync(p, { recursive: true }); }

function waitForTcp(host, port, timeoutMs = 12000, intervalMs = 150) {
  return new Promise((resolve, reject) => {
    const start = Date.now();
    const tryOnce = () => {
      const s = new net.Socket();
      s.once('connect', () => { s.destroy(); resolve(); });
      s.once('error', () => {
        s.destroy();
        if (Date.now() - start > timeoutMs) reject(new Error(`Timeout waiting for ${host}:${port}`));
        else setTimeout(tryOnce, intervalMs);
      });
      s.setTimeout(intervalMs, () => s.destroy());
      s.connect(port, host);
    };
    tryOnce();
  });
}

// ----- Write a mediamtx.yml identical in behavior to yours -----
function buildMTXYamlExact() {
  // Construct the exact block you gave
  const hosts = ADDITIONAL_HOSTS.map(h => `"${h}"`).join(', ');
  return `# Generated by mediamtxManager.js

# WebRTC ports (UDP + optional TCP)
webrtcLocalUDPAddress: :${WEBRTC_UDP}
webrtcLocalTCPAddress: :${WEBRTC_TCP}

# Add ALL hostnames/IPs clients may use to reach MediaMTX (LAN + public DNS)
webrtcAdditionalHosts: [ ${hosts} ]

# ICE servers (STUN is often enough; add TURN for tough NATs)
webrtcICEServers2:
  - url: stun:stun.l.google.com:19302
  # Uncomment when you have a TURN box (coturn recommended)
  # - url: turn:turn.yourdomain.example:3478
  #   username: webrtc
  #   password: secret

# (optional) Serve under a sub-path if reverse-proxying
# path: /mtx

# Default HTTP and WebRTC endpoints (keep defaults)
# httpAddress: :${HTTP_PORT}
# webrtcAddress: :${HTTP_PORT}
# rtspAddress: :${RTSP_PORT}

# ... keep your existing webrtc* settings ...

paths:
  all:
    # allow a publisher (like ffmpeg) to create any path on-the-fly
    source: publisher
`;
}

function writeMTXConfig() {
  ensureDir(CONFIG_DIR);
  const cfgPath = path.join(CONFIG_DIR, 'mediamtx.yml');
  fs.writeFileSync(cfgPath, buildMTXYamlExact(), 'utf8');
  return cfgPath;
}

// ----- Process control -----
async function startMediaMTX() {
  if (state.mediamtx.running || startingMTX) return;
  startingMTX = true;
  try {
    const cfgPath = writeMTXConfig();
    logger.info(`Starting MediaMTX with ${cfgPath}`);
    mediamtxProcess = spawn(MEDIAMTX_BINARY_PATH, [cfgPath], { stdio: ['ignore', 'pipe', 'pipe'] });

    state.mediamtx = { running: true, pid: mediamtxProcess.pid, startedAt: Date.now() };
    emitStatus();

    mediamtxProcess.stdout.on('data', d => emitLog('mediamtx', d.toString()));
    mediamtxProcess.stderr.on('data', d => emitLog('mediamtx', d.toString()));
    mediamtxProcess.on('exit', (code, signal) => {
      logger.warn(`MediaMTX exited (code=${code}, signal=${signal})`);
      state.mediamtx = { running: false, pid: null, startedAt: null };
      mediamtxProcess = null;
      emitStatus();
    });

    // Wait until HTTP and RTSP are listening
    await waitForTcp('127.0.0.1', HTTP_PORT);
    await waitForTcp('127.0.0.1', RTSP_PORT);
    logger.info('MediaMTX is listening.');
  } catch (err) {
    logger.error(`Failed to start MediaMTX: ${err.message}`);
    emitErr('mediamtx', err.message);
  } finally {
    startingMTX = false;
  }
}

function stopMediaMTX() {
  if (!mediamtxProcess) return;
  logger.info('Stopping MediaMTX…');
  try { mediamtxProcess.kill('SIGTERM'); } catch {}
}

async function startFFmpeg() {
  if (state.ffmpeg.running || startingFF) return;
  startingFF = true;
  try {
    if (!state.mediamtx.running) await startMediaMTX();
    await waitForTcp('127.0.0.1', RTSP_PORT);

    const args = [
      // exactly your command / options:
      '-fflags', 'nobuffer', '-flags', 'low_delay', '-use_wallclock_as_timestamps', '1',
      '-thread_queue_size', '512',
      '-f', 'v4l2', '-input_format', 'h264', '-framerate', '30', '-video_size', '640x480', '-i', CAMERA_DEVICE_PATH,
      '-thread_queue_size', '512',
      '-f', 'alsa', '-ac', '1', '-ar', '48000', '-i', AUDIO_DEVICE_ALSA,
      '-map', '0:v:0', '-map', '1:a:0',
      '-c:v', 'copy',
      '-c:a', 'libopus', '-b:a', '64k', '-ar', '48000', '-ac', '1', '-application', 'lowdelay', '-frame_duration', '20',
      '-muxdelay', '0', '-muxpreload', '0', '-max_interleave_delta', '0',
      '-f', 'rtsp', '-rtsp_transport', 'tcp',
      `rtsp://127.0.0.1:${RTSP_PORT}/${encodeURIComponent(STREAM_NAME)}`
    ];

    logger.info(`Starting FFmpeg: ${FFMPEG_BINARY_PATH} ${args.join(' ')}`);
    ffmpegProcess = spawn(FFMPEG_BINARY_PATH, args, { stdio: ['ignore', 'pipe', 'pipe'] });

    state.ffmpeg = { running: true, pid: ffmpegProcess.pid, startedAt: Date.now() };
    emitStatus();

    ffmpegProcess.stdout.on('data', d => emitLog('ffmpeg', d.toString()));
    ffmpegProcess.stderr.on('data', d => emitLog('ffmpeg', d.toString()));
    ffmpegProcess.on('exit', (code, signal) => {
      logger.warn(`FFmpeg exited (code=${code}, signal=${signal})`);
      state.ffmpeg = { running: false, pid: null, startedAt: null };
      ffmpegProcess = null;
      emitStatus();
    });

  } catch (err) {
    logger.error(`Failed to start FFmpeg: ${err.message}`);
    emitErr('ffmpeg', err.message);
  } finally {
    startingFF = false;
  }
}

function stopFFmpeg() {
  if (!ffmpegProcess) return;
  logger.info('Stopping FFmpeg…');
  try { ffmpegProcess.kill('SIGTERM'); } catch {}
}

async function startAV() { await startMediaMTX(); await startFFmpeg(); }
function stopAV() { stopFFmpeg(); setTimeout(stopMediaMTX, 400); }

// ----- Socket.IO controls -----
io.on('connection', (socket) => {
  socket.on('mediamtx:start', () => startMediaMTX());
  socket.on('mediamtx:stop',  () => stopMediaMTX());
  socket.on('mediamtx:restart', async () => { stopMediaMTX(); setTimeout(startMediaMTX, 1000); });
  socket.on('mediamtx:status', () => emitStatus());

  socket.on('ffmpeg:start', () => startFFmpeg());
  socket.on('ffmpeg:stop',  () => stopFFmpeg());
  socket.on('ffmpeg:restart', async () => { stopFFmpeg(); setTimeout(startFFmpeg, 1000); });
  socket.on('ffmpeg:status', () => emitStatus());

  socket.on('av:start', () => startAV());
  socket.on('av:stop',  () => stopAV());
  socket.on('av:restart', async () => { stopAV(); setTimeout(startAV, 1000); });

  // push current status on connect
  emitStatus();
});

// ----- Graceful shutdown -----
function cleanup() {
  try { stopFFmpeg(); } catch {}
  try { stopMediaMTX(); } catch {}
  setTimeout(() => {
    try { if (ffmpegProcess) ffmpegProcess.kill('SIGKILL'); } catch {}
    try { if (mediamtxProcess) mediamtxProcess.kill('SIGKILL'); } catch {}
  }, 2500);
}
process.on('SIGINT', cleanup);
process.on('SIGTERM', cleanup);

// Optional autostart
(async () => {
  if (AUTO_START) {
    logger.info('Auto-start enabled: starting MediaMTX + FFmpeg…');
    try { await startAV(); } catch (e) { logger.error(`Auto-start failed: ${e.message}`); }
  }
})();

module.exports = {
  startMediaMTX, stopMediaMTX,
  startFFmpeg,   stopFFmpeg,
  startAV,       stopAV,
  status: () => ({ mediamtx: state.mediamtx, ffmpeg: state.ffmpeg })
};
