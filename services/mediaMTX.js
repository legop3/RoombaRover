const fs = require('fs');
const path = require('path');
const net = require('net');
const { spawn } = require('child_process');

const config = require('../helpers/config');
const { createLogger } = require('../helpers/logger');
const { io } = require('../globals/wsSocketExpress');

const logger = createLogger('MediaMTX');

const CAMERA_DEVICE_PATH = config.mediamtx?.cameraDevicePath || '/dev/video2';
const AUDIO_DEVICE_ALSA  = config.mediamtx?.audioDevice || 'plughw:2,0';
const STREAM_NAME        = config.mediamtx?.streamName || 'rover-video';

const MEDIAMTX_BINARY_PATH = config.mediamtx?.binaryPath || 'mediamtx';
const FFMPEG_BINARY_PATH   = config.mediamtx?.ffmpegPath || 'ffmpeg';
const CONFIG_DIR           = config.mediamtx?.configDir || path.join(process.cwd(), 'runtime');
const AUTO_START           = !!config.mediamtx?.autoStart;

const HTTP_PORT = config.mediamtx?.httpPort || 8889;
const RTSP_PORT = config.mediamtx?.rtspPort || 8554;
const WEBRTC_UDP = config.mediamtx?.webrtcUdpPort || 8189;
const WEBRTC_TCP = config.mediamtx?.webrtcTcpPort || 8189;
const ADDITIONAL_HOSTS = Array.isArray(config.mediamtx?.additionalHosts) && config.mediamtx.additionalHosts.length
  ? config.mediamtx.additionalHosts
  : ['localhost'];
const STUN_SERVERS = Array.isArray(config.mediamtx?.stunServers) && config.mediamtx.stunServers.length
  ? config.mediamtx.stunServers
  : ['stun:stun.l.google.com:19302', 'stun:stun.cloudflare.com:3478'];

logger.info(`Using MediaMTX binary: ${MEDIAMTX_BINARY_PATH}`);
logger.info(`Using FFMPEG binary: ${FFMPEG_BINARY_PATH}`);
logger.info(`Camera device: ${CAMERA_DEVICE_PATH}`);
logger.info(`Audio device: ${AUDIO_DEVICE_ALSA}`);

let mediamtxProcess = null;
let ffmpegProcess = null;

const state = {
  mediamtx: { running: false, pid: null, startedAt: null, lastError: null },
  ffmpeg:   { running: false, pid: null, startedAt: null, lastError: null },
};

const sched = {
  mtx: { timer: null, attempt: 0 },
  ff:  { timer: null, attempt: 0 },
};

function emitStatus() {
  io.emit('mediamtx:status', { ...state.mediamtx });
  io.emit('ffmpeg:status', { ...state.ffmpeg });
}
function emitLog(channel, line) {
  io.emit(`${channel}:log`, String(line));
  logger.debug(`[${channel}] ${String(line).trimEnd()}`);
}
function emitErr(channel, msg) {
  io.emit(`${channel}:error`, String(msg));
  logger.warn(`[${channel}] ${msg}`);
}

function clearTimer(which) {
  if (sched[which].timer) {
    clearTimeout(sched[which].timer);
    sched[which].timer = null;
  }
}

function backoff(which, fn) {
  clearTimer(which);
  const attempt = ++sched[which].attempt;
  const delay = Math.min(10000, Math.floor(500 * Math.pow(1.6, attempt)));
  sched[which].timer = setTimeout(() => {
    sched[which].timer = null;
    fn().catch(() => {});
  }, delay);
}

function waitForTcp(host, port, timeoutMs = 12000) {
  return new Promise((resolve, reject) => {
    const start = Date.now();
    const attempt = () => {
      const socket = new net.Socket();
      socket.setTimeout(500);
      socket.once('connect', () => {
        socket.destroy();
        resolve();
      });
      socket.once('error', () => {
        socket.destroy();
        if (Date.now() - start > timeoutMs) reject(new Error(`Timeout waiting for ${host}:${port}`));
        else setTimeout(attempt, 300);
      });
      socket.once('timeout', () => {
        socket.destroy();
        if (Date.now() - start > timeoutMs) reject(new Error(`Timeout waiting for ${host}:${port}`));
        else setTimeout(attempt, 300);
      });
      try {
        socket.connect(port, host);
      } catch {
        setTimeout(attempt, 300);
      }
    };
    attempt();
  });
}

function buildLocalConfig() {
  const hosts = ADDITIONAL_HOSTS.map(h => `"${h}"`).join(', ');
  const stunEntries = STUN_SERVERS.map(url => `  - url: ${url}`).join('\n');
  return `# Generated by RoombaRover

rtspAddress: :${RTSP_PORT}
webrtcAddress: :${HTTP_PORT}
webrtcLocalUDPAddress: :${WEBRTC_UDP}
webrtcLocalTCPAddress: :${WEBRTC_TCP}
webrtcAdditionalHosts: [ ${hosts} ]

webrtcICEServers2:
${stunEntries}

paths:
  all:
    source: publisher
`;
}

function writeLocalConfig() {
  fs.mkdirSync(CONFIG_DIR, { recursive: true });
  const cfgPath = path.join(CONFIG_DIR, 'mediamtx.yml');
  fs.writeFileSync(cfgPath, buildLocalConfig(), 'utf8');
  return cfgPath;
}

async function startMediaMTX() {
  if (mediamtxProcess || state.mediamtx.running) return;

  clearTimer('mtx');
  state.mediamtx.lastError = null;
  emitStatus();

  const cfgPath = writeLocalConfig();

  logger.info(`Starting MediaMTX with ${cfgPath}`);
  let child;
  try {
    child = spawn(MEDIAMTX_BINARY_PATH, [cfgPath], { stdio: ['ignore', 'pipe', 'pipe'] });
  } catch (error) {
    const msg = error && error.code === 'ENOENT'
      ? `MediaMTX binary not found: ${MEDIAMTX_BINARY_PATH}`
      : `Failed to spawn MediaMTX: ${error.message}`;
    emitErr('mediamtx', msg);
    state.mediamtx.lastError = msg;
    emitStatus();
    backoff('mtx', startMediaMTX);
    return;
  }

  mediamtxProcess = child;
  state.mediamtx = { running: true, pid: child.pid, startedAt: Date.now(), lastError: null };
  emitStatus();

  child.stdout.on('data', data => emitLog('mediamtx', data.toString()));
  child.stderr.on('data', data => emitLog('mediamtx', data.toString()));

  child.on('exit', (code, signal) => {
    emitErr('mediamtx', `MediaMTX exited (code=${code}, signal=${signal})`);
    mediamtxProcess = null;
    state.mediamtx = { running: false, pid: null, startedAt: null, lastError: `code=${code}, signal=${signal}` };
    emitStatus();
    if (ffmpegProcess) stopFFmpeg();
    backoff('mtx', startMediaMTX);
  });

  try {
    await waitForTcp('127.0.0.1', RTSP_PORT, 10000);
    await waitForTcp('127.0.0.1', HTTP_PORT, 10000);
    sched.mtx.attempt = 0;
    logger.info('MediaMTX listening locally.');
  } catch (error) {
    emitErr('mediamtx', `MediaMTX ports not ready: ${error.message}`);
  }
}

function stopMediaMTX() {
  clearTimer('mtx');
  if (!mediamtxProcess) return;
  try { mediamtxProcess.kill('SIGTERM'); } catch {}
}

function killMediaMTX() {
  if (!mediamtxProcess) return;
  try { mediamtxProcess.kill('SIGKILL'); } catch {}
}

function ffmpegArgsExact() {
  return [
    '-fflags', 'nobuffer', '-flags', 'low_delay', '-use_wallclock_as_timestamps', '1',
    '-thread_queue_size', '512',
    '-f', 'v4l2', '-input_format', 'h264', '-framerate', '30', '-video_size', '640x480', '-v4l2-ctl', 'power_line_frequency=2', '-i', CAMERA_DEVICE_PATH,
    '-thread_queue_size', '512',
    '-f', 'alsa', '-ac', '1', '-ar', '48000', '-i', AUDIO_DEVICE_ALSA,
    '-map', '0:v:0', '-map', '1:a:0',
    '-c:v', 'copy',
    '-c:a', 'libopus', '-b:a', '64k', '-ar', '48000', '-ac', '1', '-application', 'lowdelay', '-frame_duration', '20',
    '-muxdelay', '0', '-muxpreload', '0', '-max_interleave_delta', '0',
    '-f', 'rtsp', '-rtsp_transport', 'tcp',
    `rtsp://127.0.0.1:${RTSP_PORT}/${encodeURIComponent(STREAM_NAME)}`
  ];
}

async function startFFmpeg() {
  if (ffmpegProcess || state.ffmpeg.running) return;

  clearTimer('ff');
  state.ffmpeg.lastError = null;
  emitStatus();

  if (!mediamtxProcess && !state.mediamtx.running) await startMediaMTX();
  try { await waitForTcp('127.0.0.1', RTSP_PORT, 10000); } catch {}

  let child;
  const args = ffmpegArgsExact();
  try {
    child = spawn(FFMPEG_BINARY_PATH, args, { stdio: ['ignore', 'pipe', 'pipe'] });
  } catch (error) {
    const msg = error && error.code === 'ENOENT'
      ? `FFmpeg binary not found: ${FFMPEG_BINARY_PATH}`
      : `Failed to spawn FFmpeg: ${error.message}`;
    emitErr('ffmpeg', msg);
    state.ffmpeg.lastError = msg;
    emitStatus();
    backoff('ff', startFFmpeg);
    return;
  }

  ffmpegProcess = child;
  state.ffmpeg = { running: true, pid: child.pid, startedAt: Date.now(), lastError: null };
  emitStatus();

  const stderrBuffer = [];
  const stdoutBuffer = [];

  child.stdout.on('data', data => {
    const text = data.toString();
    stdoutBuffer.push(text.trimEnd());
    if (stdoutBuffer.length > 25) stdoutBuffer.shift();
    emitLog('ffmpeg', text);
  });
  child.stderr.on('data', data => {
    const text = data.toString();
    stderrBuffer.push(text.trimEnd());
    if (stderrBuffer.length > 25) stderrBuffer.shift();
    emitLog('ffmpeg', text);
    if (/\bNo such file or directory\b|\bInput\/output error\b|\bDevice or resource busy\b/i.test(text)) {
      state.ffmpeg.lastError = text.trim();
      emitStatus();
    }
  });

  child.on('exit', (code, signal) => {
    const lastLine = stderrBuffer.at(-1) || stdoutBuffer.at(-1) || 'no output captured';
    emitErr('ffmpeg', `FFmpeg exited (code=${code}, signal=${signal}) last output: ${lastLine}`);
    ffmpegProcess = null;
    state.ffmpeg = { running: false, pid: null, startedAt: null, lastError: state.ffmpeg.lastError };
    emitStatus();
    backoff('ff', startFFmpeg);
  });
}

function stopFFmpeg() {
  clearTimer('ff');
  if (!ffmpegProcess) return;
  try { ffmpegProcess.kill('SIGTERM'); } catch {}
}

function killFFmpeg() {
  if (!ffmpegProcess) return;
  try { ffmpegProcess.kill('SIGKILL'); } catch {}
}

async function startAV() {
  await startMediaMTX();
  await startFFmpeg();
}

function stopAV() {
  stopFFmpeg();
  setTimeout(stopMediaMTX, 400);
}

io.on('connection', socket => {
  socket.on('mediamtx:start', () => { startMediaMTX().catch(() => {}); });
  socket.on('mediamtx:stop', () => { stopMediaMTX(); });
  socket.on('mediamtx:restart', () => { stopMediaMTX(); setTimeout(() => startMediaMTX().catch(() => {}), 700); });
  socket.on('mediamtx:status', () => emitStatus());

  socket.on('ffmpeg:start', () => { startFFmpeg().catch(() => {}); });
  socket.on('ffmpeg:stop', () => { stopFFmpeg(); });
  socket.on('ffmpeg:restart', () => { stopFFmpeg(); setTimeout(() => startFFmpeg().catch(() => {}), 700); });
  socket.on('ffmpeg:status', () => emitStatus());

  socket.on('av:start', () => { startAV().catch(() => {}); });
  socket.on('av:stop', () => { stopAV(); });
  socket.on('av:restart', () => { stopAV(); setTimeout(() => startAV().catch(() => {}), 1000); });

  emitStatus();
});

function cleanup() {
  try { stopFFmpeg(); } catch {}
  try { stopMediaMTX(); } catch {}
  setTimeout(() => {
    try { killFFmpeg(); } catch {}
    try { killMediaMTX(); } catch {}
  }, 2000);
}

function shutdown(code = 0) {
  clearTimer('ff');
  clearTimer('mtx');
  cleanup();
  setTimeout(() => process.exit(code), 2500);
}

process.once('SIGINT', () => { logger.info('SIGINT received'); shutdown(0); });
process.once('SIGTERM', () => { logger.info('SIGTERM received'); shutdown(0); });
process.once('SIGUSR2', () => { logger.info('SIGUSR2 received'); shutdown(0); });

process.on('uncaughtException', err => {
  logger.error(`uncaughtException: ${err.stack || err.message}`);
  emitErr('manager', `uncaughtException: ${err.message}`);
});
process.on('unhandledRejection', reason => {
  logger.error(`unhandledRejection: ${reason && reason.stack || reason}`);
  emitErr('manager', `unhandledRejection: ${reason}`);
});

(async () => {
  if (AUTO_START) {
    logger.info('Auto-start enabled: starting AV pipeline…');
    try { await startAV(); } catch (error) { logger.error(`Auto-start failed: ${error.message}`); }
  }
})();

module.exports = {
  startMediaMTX,
  stopMediaMTX,
  startFFmpeg,
  stopFFmpeg,
  startAV,
  stopAV,
  status: () => ({ mediamtx: state.mediamtx, ffmpeg: state.ffmpeg }),
};
