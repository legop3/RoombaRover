<div style="max-width:960px;margin:0 auto">
    <video id="rv" playsinline autoplay style="width:100%;background:#000;border-radius:8px"></video>
    <div id="rvStatus" style="font:12px/1.2 monospace;opacity:.8;margin-top:6px">idle</div>
  </div>
  
  <script>
  (async () => {
    const video  = document.getElementById('rv');
    const status = document.getElementById('rvStatus');
    const log = (m,...a)=>{ status.textContent = m; console.log('[WHEP]', m, ...a); };
    const err = (m,...a)=>{ status.textContent = m; console.error('[WHEP]', m, ...a); };
  
    async function getWhepUrl() {
      const r = await fetch('/video-url', { cache: 'no-store' });
      const t = (await r.text()).trim();
      if (!r.ok || !t || /^</.test(t)) throw new Error('/video-url invalid response');
      return t; // e.g. https://rover.otter.land/rover-video/whep
    }
  
    // Send a single trickle candidate using sdpfrag; if that fails, try JSON
    async function patchCandidate(resourceUrl, candidate, mid, mLineIndex) {
      // Content-Type: application/trickle-ice-sdpfrag
      const sdpfrag =
  `a=ice-ufrag:${(window.__localUfrag||'')}
  m=${mid||'0'} 9 UDP/TLS/RTP/SAVPF 96
  a=mid:${mid||'0'}
  ${candidate ? 'a=' + candidate.candidate : 'a=end-of-candidates'}
  `;
      try {
        const r = await fetch(resourceUrl, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/trickle-ice-sdpfrag' },
          body: sdpfrag
        });
        if (r.ok || r.status === 204) return true;
      } catch {}
      // Fallback: application/trickle-ice+json
      try {
        const body = candidate ? {
          candidate: candidate.candidate,
          sdpMid: mid,
          sdpMLineIndex: mLineIndex
        } : { candidate: '' }; // end-of-candidates
        const r2 = await fetch(resourceUrl, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/trickle-ice+json' },
          body: JSON.stringify(body)
        });
        return (r2.ok || r2.status === 204);
      } catch {}
      return false;
    }
  
    try {
      const whepUrl = await getWhepUrl();
      log('connecting…');
  
      const pc = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });
  
      // Build a MediaStream and attach tracks as they arrive
      const ms = new MediaStream();
      video.srcObject = ms;
  
      const v = pc.addTransceiver('video', { direction: 'recvonly' });
      pc.addTransceiver('audio', { direction: 'recvonly' });
  
      // Prefer H.264 first if present (harmless if not)
      try {
        const caps = RTCRtpReceiver.getCapabilities('video');
        const h264s = (caps?.codecs||[]).filter(c => /H264/i.test(c.mimeType));
        if (h264s.length) v.setCodecPreferences(h264s.concat(caps.codecs.filter(c => !/H264/i.test(c.mimeType))));
      } catch {}
  
      pc.ontrack = (ev) => { ms.addTrack(ev.track); };
  
      pc.oniceconnectionstatechange = () => {
        console.debug('[pc] ice:', pc.iceConnectionState);
        if (pc.iceConnectionState === 'connected') log('playing');
      };
  
      // --- Create offer and POST to make a WHEP resource
      const offer = await pc.createOffer({ offerToReceiveVideo: true, offerToReceiveAudio: true });
      await pc.setLocalDescription(offer);
  
      // Extract local ufrag (useful for sdpfrag format)
      try {
        const m = pc.localDescription.sdp.match(/a=ice-ufrag:(.+)/);
        if (m) window.__localUfrag = m[1].trim();
      } catch {}
  
      // POST the initial offer (do NOT wait for ice gather to complete)
      const createResp = await fetch(whepUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/sdp' },
        body: pc.localDescription.sdp
      });
  
      if (!(createResp.ok || createResp.status === 201)) {
        throw new Error(`WHEP create ${createResp.status}`);
      }
  
      const answerSdp = await createResp.text();
      const resourceURL = createResp.headers.get('Location') || createResp.headers.get('location');
      if (!/^\s*m=video\s/im.test(answerSdp)) throw new Error('answer SDP missing video m-line');
      await pc.setRemoteDescription({ type: 'answer', sdp: answerSdp });
  
      // --- Trickle: send candidates as they arrive
      if (!resourceURL) {
        console.warn('[WHEP] No Location header; server may not support trickle PATCH. (We’ll still try without.)');
      }
  
      pc.onicecandidate = async (ev) => {
        // Null candidate signals end-of-candidates
        if (!resourceURL) return; // nothing we can PATCH to
        try {
          if (ev.candidate) {
            await patchCandidate(resourceURL, ev.candidate, ev.candidate.sdpMid, ev.candidate.sdpMLineIndex);
          } else {
            await patchCandidate(resourceURL, null);
          }
        } catch (e) {
          console.warn('[WHEP] trickle patch failed:', e?.message || e);
        }
      };
  
      // Try to autoplay UNMUTED first
      video.muted = false;
      try {
        await video.play();
        log('playing');
      } catch {
        video.muted = true;
        await video.play().catch(()=>{});
        log('autoplay blocked — started muted');
      }
  
    } catch (e) {
      err(e.message || e);
    }
  })();
  </script>
  